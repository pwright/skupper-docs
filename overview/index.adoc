
//Category: skupper-overview
// Type: assembly

[id="skupper-overview"] 
= Skupper overview

Hybrid clouds enable organizations to combine on-premises, private cloud, and public cloud resources.
While such a solution provides many benefits, it also presents a unique challenge: enabling these resources to communicate with each other.

Skupper provides a solution to this challenge with a {service-network} that simply and securely connects applications running in different network locations.

// Type: concept
[id="virtual-application-networks"] 
== {service-network}s

Skupper solves multi-cluster communication challenges through something called a {service-network}.
To understand the value of Skupper, it is helpful to first understand what a {service-network} is.

A {service-network} connects the applications and services in your hybrid cloud into a virtual network so that they can communicate with each other as if they were all running in the same site.
In this diagram, a {service-network} connects three services, each of which is running in a different cloud:

image::../images/overview-clouds.png[]

In essence, the {service-network} connects the services in a distributed application with a microservice architecture.

image::../images/overview-application.png[]

{service-network}s are able to provide connectivity across the hybrid cloud because they operate at Layer 7 (the application layer).
They use *Layer 7 application routers* to route communication between *Layer 7 application addresses*.

// Type: concept
[id="layer-7-application-routers"] 
== Layer 7 application routers

Layer 7 application routers form the backbone of a {service-network} in the same way that conventional network routers form the backbone of a VPN.
However, instead of routing IP packets between network endpoints, Layer 7 application routers route messages between application endpoints (called routing keys).

// Type: concept
[id="layer-7-application-addresses"]
== Layer 7 application addresses and routing keys

A Layer 7 application address represents an endpoint, or destination in the {service-network}.
A *routing key* consists of a name and port and is the Skupper address on the {service-network}.
When an application sends a communication to a routing key, the Layer 7 application routers distribute the communication to any other application in the {service-network} that has the same routing key.

For example, in this diagram, *Service B* sends a message with an routing key to its local application router.
*Service A* and *Service C* are subscribed to the same routing key, so the application router routes copies of the message through the {service-network} until they arrive at each destination.

image::../images/overview-routers.png[]

{service-network}s provide multiple routing patterns, so communications can be distributed in anycast (balanced or closest) or multicast patterns.

// Type: concept
[id="skupper"] 
== Skupper

Skupper is an open source tool for creating {service-network}s in Kubernetes and on Linux.
By using Skupper, you can create a distributed application consisting of microservices running in different Kubernetes clusters and/or Linux hosts.

This diagram illustrates a Skupper network that connects three services running in three different Kubernetes clusters:

image::../images/overview-clusters.png[]

In a Skupper network, each namespace contains a Skupper instance.
When these Skupper instances connect, they continually share information about the services that each instance exposes.
This means that each Skupper instance is always aware of every service that has been exposed to the Skupper network, regardless of the namespace in which each service resides.

Once a Skupper network is formed across Kubernetes namespaces and/or Linux users, any of the services in those sites can be exposed (through annotation) to the Skupper network.
When a service is exposed and a user creates a matching routing key on a site, Skupper creates proxy endpoints to make that service available on each site in the Skupper network.

.Additional information

* xref:security.adoc[Security]
* xref:routing.adoc[Routing]
* xref:connectivity.adoc[Connectivity]
